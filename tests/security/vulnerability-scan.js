const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Vulnerability scan configuration
const config = {
  scanTypes: [
    'npm-audit',
    'snyk',
    'retire',
    'safety',
    'bandit',
    'semgrep',
  ],
  outputDir: path.join(__dirname, '..', '..', 'quality-reports'),
  severityLevels: ['LOW', 'MODERATE', 'HIGH', 'CRITICAL'],
  excludePatterns: [
    'node_modules/**',
    'coverage/**',
    'dist/**',
    'build/**',
    '*.min.js',
    '*.bundle.js',
  ],
};

// Vulnerability scan results
const results = {
  timestamp: new Date().toISOString(),
  scans: {},
  summary: {
    total: 0,
    critical: 0,
    high: 0,
    moderate: 0,
    low: 0,
  },
  recommendations: [],
};

// Run npm audit
const runNpmAudit = async () => {
  console.log('🔍 Running npm audit...');
  
  try {
    const output = execSync('npm audit --json', { encoding: 'utf8' });
    const audit = JSON.parse(output);
    
    const vulnerabilities = [];
    if (audit.vulnerabilities) {
      Object.entries(audit.vulnerabilities).forEach(([name, vuln]) => {
        vulnerabilities.push({
          name,
          severity: vuln.severity?.toUpperCase() || 'UNKNOWN',
          title: vuln.title || name,
          description: vuln.description || 'No description available',
          recommendation: vuln.remediation || 'Update to latest version',
          package: name,
          version: vuln.range || 'Unknown',
          patched: vuln.patched_versions || 'Not available',
        });
      });
    }
    
    return {
      type: 'npm-audit',
      success: true,
      vulnerabilities,
      summary: {
        total: vulnerabilities.length,
        critical: vulnerabilities.filter(v => v.severity === 'CRITICAL').length,
        high: vulnerabilities.filter(v => v.severity === 'HIGH').length,
        moderate: vulnerabilities.filter(v => v.severity === 'MODERATE').length,
        low: vulnerabilities.filter(v => v.severity === 'LOW').length,
      },
    };
    
  } catch (error) {
    console.log(`  ❌ npm audit failed: ${error.message}`);
    return {
      type: 'npm-audit',
      success: false,
      error: error.message,
      vulnerabilities: [],
      summary: { total: 0, critical: 0, high: 0, moderate: 0, low: 0 },
    };
  }
};

// Run Snyk scan
const runSnykScan = async () => {
  console.log('🔍 Running Snyk scan...');
  
  try {
    // Check if Snyk is installed
    execSync('snyk --version', { stdio: 'pipe' });
    
    const output = execSync('snyk test --json', { encoding: 'utf8' });
    const snyk = JSON.parse(output);
    
    const vulnerabilities = snyk.vulnerabilities?.map(vuln => ({
      name: vuln.name,
      severity: vuln.severity?.toUpperCase() || 'UNKNOWN',
      title: vuln.title || vuln.name,
      description: vuln.description || 'No description available',
      recommendation: vuln.remediation || 'Update to latest version',
      package: vuln.name,
      version: vuln.version || 'Unknown',
      patched: vuln.upgradePath?.[0] || 'Not available',
      cve: vuln.identifiers?.CVE?.[0] || null,
    })) || [];
    
    return {
      type: 'snyk',
      success: true,
      vulnerabilities,
      summary: {
        total: vulnerabilities.length,
        critical: vulnerabilities.filter(v => v.severity === 'CRITICAL').length,
        high: vulnerabilities.filter(v => v.severity === 'HIGH').length,
        moderate: vulnerabilities.filter(v => v.severity === 'MODERATE').length,
        low: vulnerabilities.filter(v => v.severity === 'LOW').length,
      },
    };
    
  } catch (error) {
    console.log(`  ❌ Snyk scan failed: ${error.message}`);
    return {
      type: 'snyk',
      success: false,
      error: error.message,
      vulnerabilities: [],
      summary: { total: 0, critical: 0, high: 0, moderate: 0, low: 0 },
    };
  }
};

// Run Retire.js scan
const runRetireScan = async () => {
  console.log('🔍 Running Retire.js scan...');
  
  try {
    // Check if retire is installed
    execSync('retire --version', { stdio: 'pipe' });
    
    const output = execSync('retire --json', { encoding: 'utf8' });
    const retire = JSON.parse(output);
    
    const vulnerabilities = [];
    retire.forEach(file => {
      if (file.results) {
        file.results.forEach(result => {
          result.vulnerabilities?.forEach(vuln => {
            vulnerabilities.push({
              name: result.component,
              severity: vuln.severity?.toUpperCase() || 'UNKNOWN',
              title: vuln.identifiers?.summary || result.component,
              description: vuln.info?.[0] || 'No description available',
              recommendation: 'Update to latest version',
              package: result.component,
              version: result.version || 'Unknown',
              patched: 'Not available',
              file: file.file,
            });
          });
        });
      }
    });
    
    return {
      type: 'retire',
      success: true,
      vulnerabilities,
      summary: {
        total: vulnerabilities.length,
        critical: vulnerabilities.filter(v => v.severity === 'CRITICAL').length,
        high: vulnerabilities.filter(v => v.severity === 'HIGH').length,
        moderate: vulnerabilities.filter(v => v.severity === 'MODERATE').length,
        low: vulnerabilities.filter(v => v.severity === 'LOW').length,
      },
    };
    
  } catch (error) {
    console.log(`  ❌ Retire.js scan failed: ${error.message}`);
    return {
      type: 'retire',
      success: false,
      error: error.message,
      vulnerabilities: [],
      summary: { total: 0, critical: 0, high: 0, moderate: 0, low: 0 },
    };
  }
};

// Run Safety scan (Python dependencies)
const runSafetyScan = async () => {
  console.log('🔍 Running Safety scan...');
  
  try {
    // Check if safety is installed
    execSync('safety --version', { stdio: 'pipe' });
    
    const output = execSync('safety check --json', { encoding: 'utf8' });
    const safety = JSON.parse(output);
    
    const vulnerabilities = safety.map(vuln => ({
      name: vuln.package_name,
      severity: vuln.severity?.toUpperCase() || 'UNKNOWN',
      title: vuln.advisory || vuln.package_name,
      description: vuln.advisory || 'No description available',
      recommendation: 'Update to latest version',
      package: vuln.package_name,
      version: vuln.analyzed_version || 'Unknown',
      patched: vuln.safe_version || 'Not available',
      cve: vuln.cve || null,
    }));
    
    return {
      type: 'safety',
      success: true,
      vulnerabilities,
      summary: {
        total: vulnerabilities.length,
        critical: vulnerabilities.filter(v => v.severity === 'CRITICAL').length,
        high: vulnerabilities.filter(v => v.severity === 'HIGH').length,
        moderate: vulnerabilities.filter(v => v.severity === 'MODERATE').length,
        low: vulnerabilities.filter(v => v.severity === 'LOW').length,
      },
    };
    
  } catch (error) {
    console.log(`  ❌ Safety scan failed: ${error.message}`);
    return {
      type: 'safety',
      success: false,
      error: error.message,
      vulnerabilities: [],
      summary: { total: 0, critical: 0, high: 0, moderate: 0, low: 0 },
    };
  }
};

// Run Bandit scan (Python security)
const runBanditScan = async () => {
  console.log('🔍 Running Bandit scan...');
  
  try {
    // Check if bandit is installed
    execSync('bandit --version', { stdio: 'pipe' });
    
    const output = execSync('bandit -r . -f json', { encoding: 'utf8' });
    const bandit = JSON.parse(output);
    
    const vulnerabilities = bandit.results?.map(result => ({
      name: result.test_name,
      severity: result.issue_severity?.toUpperCase() || 'UNKNOWN',
      title: result.test_name,
      description: result.issue_text || 'No description available',
      recommendation: 'Review and fix the security issue',
      package: 'Python Code',
      version: 'N/A',
      patched: 'N/A',
      file: result.filename,
      line: result.line_number,
      confidence: result.issue_confidence,
    })) || [];
    
    return {
      type: 'bandit',
      success: true,
      vulnerabilities,
      summary: {
        total: vulnerabilities.length,
        critical: vulnerabilities.filter(v => v.severity === 'CRITICAL').length,
        high: vulnerabilities.filter(v => v.severity === 'HIGH').length,
        moderate: vulnerabilities.filter(v => v.severity === 'MODERATE').length,
        low: vulnerabilities.filter(v => v.severity === 'LOW').length,
      },
    };
    
  } catch (error) {
    console.log(`  ❌ Bandit scan failed: ${error.message}`);
    return {
      type: 'bandit',
      success: false,
      error: error.message,
      vulnerabilities: [],
      summary: { total: 0, critical: 0, high: 0, moderate: 0, low: 0 },
    };
  }
};

// Run Semgrep scan
const runSemgrepScan = async () => {
  console.log('🔍 Running Semgrep scan...');
  
  try {
    // Check if semgrep is installed
    execSync('semgrep --version', { stdio: 'pipe' });
    
    const output = execSync('semgrep --config=auto --json .', { encoding: 'utf8' });
    const semgrep = JSON.parse(output);
    
    const vulnerabilities = semgrep.results?.map(result => ({
      name: result.check_id,
      severity: result.extra.severity?.toUpperCase() || 'UNKNOWN',
      title: result.extra.message || result.check_id,
      description: result.extra.message || 'No description available',
      recommendation: 'Review and fix the security issue',
      package: 'Code',
      version: 'N/A',
      patched: 'N/A',
      file: result.path,
      line: result.start.line,
      rule: result.check_id,
    })) || [];
    
    return {
      type: 'semgrep',
      success: true,
      vulnerabilities,
      summary: {
        total: vulnerabilities.length,
        critical: vulnerabilities.filter(v => v.severity === 'CRITICAL').length,
        high: vulnerabilities.filter(v => v.severity === 'HIGH').length,
        moderate: vulnerabilities.filter(v => v.severity === 'MODERATE').length,
        low: vulnerabilities.filter(v => v.severity === 'LOW').length,
      },
    };
    
  } catch (error) {
    console.log(`  ❌ Semgrep scan failed: ${error.message}`);
    return {
      type: 'semgrep',
      success: false,
      error: error.message,
      vulnerabilities: [],
      summary: { total: 0, critical: 0, high: 0, moderate: 0, low: 0 },
    };
  }
};

// Run all vulnerability scans
const runAllVulnerabilityScans = async () => {
  console.log('🔒 Starting vulnerability scans...');
  console.log(`Scan types: ${config.scanTypes.join(', ')}`);
  console.log('');
  
  const scans = {
    'npm-audit': runNpmAudit,
    'snyk': runSnykScan,
    'retire': runRetireScan,
    'safety': runSafetyScan,
    'bandit': runBanditScan,
    'semgrep': runSemgrepScan,
  };
  
  for (const scanType of config.scanTypes) {
    if (scans[scanType]) {
      try {
        const result = await scans[scanType]();
        results.scans[scanType] = result;
        
        // Update summary
        results.summary.total += result.summary.total;
        results.summary.critical += result.summary.critical;
        results.summary.high += result.summary.high;
        results.summary.moderate += result.summary.moderate;
        results.summary.low += result.summary.low;
        
      } catch (error) {
        console.log(`  ❌ ${scanType} scan failed: ${error.message}`);
        results.scans[scanType] = {
          type: scanType,
          success: false,
          error: error.message,
          vulnerabilities: [],
          summary: { total: 0, critical: 0, high: 0, moderate: 0, low: 0 },
        };
      }
    }
  }
  
  // Generate recommendations
  generateRecommendations();
  
  // Generate report
  generateVulnerabilityReport();
  
  return results;
};

// Generate recommendations
const generateRecommendations = () => {
  if (results.summary.critical > 0) {
    results.recommendations.push('CRITICAL: Address critical vulnerabilities immediately');
  }
  
  if (results.summary.high > 0) {
    results.recommendations.push('HIGH: Address high-severity vulnerabilities as soon as possible');
  }
  
  if (results.summary.moderate > 0) {
    results.recommendations.push('MODERATE: Address moderate-severity vulnerabilities in next release');
  }
  
  if (results.summary.low > 0) {
    results.recommendations.push('LOW: Consider addressing low-severity vulnerabilities');
  }
  
  results.recommendations.push('Keep dependencies updated regularly');
  results.recommendations.push('Use automated vulnerability scanning in CI/CD');
  results.recommendations.push('Implement security monitoring and alerting');
  results.recommendations.push('Regular security audits and penetration testing');
};

// Generate vulnerability report
const generateVulnerabilityReport = () => {
  const report = {
    ...results,
    config,
  };
  
  // Save report
  const reportPath = path.join(config.outputDir, 'vulnerability-report.json');
  const reportDir = path.dirname(reportPath);
  
  if (!fs.existsSync(reportDir)) {
    fs.mkdirSync(reportDir, { recursive: true });
  }
  
  fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
  console.log(`\n📁 Vulnerability report saved to: ${reportPath}`);
  
  // Display summary
  console.log('\n📊 Vulnerability Scan Summary:');
  console.log('==============================');
  console.log(`Total vulnerabilities: ${results.summary.total}`);
  console.log(`Critical: ${results.summary.critical}`);
  console.log(`High: ${results.summary.high}`);
  console.log(`Moderate: ${results.summary.moderate}`);
  console.log(`Low: ${results.summary.low}`);
  
  if (results.recommendations.length > 0) {
    console.log('\n💡 Recommendations:');
    results.recommendations.forEach(rec => console.log(`  - ${rec}`));
  }
  
  return report;
};

// Run if called directly
if (require.main === module) {
  runAllVulnerabilityScans().catch(error => {
    console.error('❌ Vulnerability scan failed:', error.message);
    process.exit(1);
  });
}

module.exports = {
  runAllVulnerabilityScans,
  runNpmAudit,
  runSnykScan,
  runRetireScan,
  runSafetyScan,
  runBanditScan,
  runSemgrepScan,
  config,
  results,
};
